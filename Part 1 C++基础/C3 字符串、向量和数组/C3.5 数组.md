# C3.5 数组
数组是一种类似标准库类型`vector`的数据结构，但是在性能和灵活性的权衡上又与`vector`有所不同。与`vector`相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。与`vector`不同的地方是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序的运行性能比较好，但是相应地也损失了一些灵活性。

## 定义和初始化内置数组
数组是一种复合类型。

数组的声明形如`a[d]`，其中`a`是数组的名字，`d`是数组的维度。

维度说明了数组中元素的个数，因此必须大于`0`。数组中元素的个数也属于数组类型的一部分，编译时维度应该是已知的。也就是说，维度必须是一个常量表达式。
```cpp
unsigned cnt = 42;            //不是常量表达式
constexpr unsigned sz = 42;   //常量表达式
int arr[10];                  //含有10个整数的数组
int *parr[sz];                //含有42个整型指针的数组
string bad[cnt];              //错误：cnt不是常量表达式
string strs[get_size()];      //当get_size是constexpr时正确；否则错误
```

默认情况下，数组的元素被默认初始化。和内置类型一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。

定义数组的时候必须指定数组的类型，不允许用`auto`关键字由初始值的列表推断类型。另外和`vector`一样，数组的元素应为对象，因此不存在引用的数组。

### 显式初始化数组元素
可以对数组的元素进行列表初始化，此时允许忽略数组的维度。如果在声明时没有指明维度，编译器回根据初始值的数量计算并推测出来；相反，如果指明了维度，那么初始值的总数量不应该超过指定的大小。如果维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素会被初始化成默认值。
```cpp
const unsigned sz = 3;
int ia1[sz] = {0,1,2};
int a2[] = {0,1,2};
int a3[5] = {0,1,2}             //等价于a3[] = {0,1,2,0,0}
string a4[3] = {"hi","bye"};
int a5[2] = {0,1,2}             //错误：初始值过多
```

### 字符数组的特殊性
字符数组有一种额外的初始化形式，我们可以用字符串字面值对此类数组初始化。当使用这种形式时一定要注意字符串字面值的结尾处还有一个空字符（`\0`），这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去：
```cpp
char a1[] = {'c','+','+'};        //列表初始化，没有空字符
char a2[] = {'c','+','+','\0'};   //列表初始化，含有显式的空字符
char a3[] = "C++";                //自动添加表示空字符串结束的空字符
const char a4[6] = "Daniel";      //错误：没有空间可存放空字符
```

### 不允许拷贝和赋值
不能将数组中的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：
```cpp
int a[] = {0,1,2};
int a2[] = a;                //错误：不允许使用一个数组初始化另一个数组
a2 = a;                      //错误：不能把一个数组直接赋值给另一个数组
```

### 理解复杂的数组声明
和`vector`一样，数组能存放大多数类型的对象。
```cpp
int *ptrs[10];                //ptrs是含有10个整型指针的数组
int &refs[10] = /* ? */;      //错误：不存在引用数组
int (*Parray)[10] = &arr;     //Parray 指向一个含有10个整数的数组
int (&arrRef)[10] = arr;      //arrRef引用一个含有10个整数的数组
```

默认情况下，类型修饰符从右向左依次绑定。对于`ptrs`来说，从右向左理解其含义比较简单：首先知道我们定义的是一个大小为10的数组，它的名字是`ptrs`，然后知道数组中存放的是指向`int`的指针。

但是对于`Parray`来说，从右向左理解就不太合理了。因为数组的维度是紧跟着被声明的名字，所以就数组而言，由内而外阅读要比从右向左好多了。由内向外的顺序可帮助我们更好地理解`Parray`的含义：首先是圆括号括起来的部分，`*Parray`意味着`Parray`是指针，接下来观察右边，可知道`Parray`是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是`int`。这样最终的含义就明白无误了，`Parray`是一个指针，它指向一个`int`数组，数组包含10个元素。同理`（&arrRef)`表示`arrRef`是一个引用，它引用的对象是一个大小为10的数组，数组中的元素类型是`int`。

### 访问数组元素
与标准库类型`vector`和`string`一样，数组的元素也能使用范围`for`语句或下标运算符来访问。数组的索引从`0`开始，以一个包含10个元素的数组为例，它的索引从`0`到`9`，而非从`1`到`10`。

在使用数组下标的时候，通常将其定义为**size_t**类型。`size_t`是一种机器相关的无符号类型，它被设计的足够大以便能够表示内存中任意对象的大小。在`cstddef`头文件中定义了`size_t`类型。

与`vector`和`string`一样，当需要遍历数组的所有元素时，最好的办法也是使用范围`for`语句。。
```cpp
for (auto i : scores)
    cout << i << " ";
cout << endl;
```

因为维度是数组类型的一部分，所以系统知道数组`scores`中有多少个元素，使用范围`for`语句可以减少人为控制遍历过程的负担。

### 检查下标的值
与`vector`和`string`一样，数组的下标是否在合理范围内有程序员负责检查，所谓合理就是说下标应该大于等于`0`而且小于等于数组的大小。

### 指针和数组
在C++ 语言中，指针和数组有非常紧密的联系。使用数组的时候编译器一般会把它转换成指针。

通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。因此像其他对象一样，对数组的元素使用取地址符就能得到指向该元素的指针：
```cpp
string nums[] = {"one","two","three"};    //数组的元素是string对象
string *p = &nums[0];                     //p指向nums的第一个元素
```

然而，数组还有一个特性：在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针：
```cpp
string *p2 = nums;        //等价于p2 = &nums[0]
```

在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针

### 指针也是迭代器
与迭代器相比，指向数组的指针拥有更多的功能。`vector`和`string`的迭代器支持的运算，数组的指针全部支持。

就像使用迭代器遍历`vector`对象中的元素一样，使用指针也能遍历数组中的元素。当然，这样做的前提是先取到指向数组第一个元素的指针和指向数组尾元素的下一位置的指针。通过数组的名字可以获取到首元素的地址；获取尾后指针就要用到数组的另外一个特殊性质了。

```cpp
int *e = &arr[10];        //指向arr尾元素的下一位置的指针（int arr[10])
```

利用上面得到的指针就能重写之前的循环，令其输出`arr`的全部元素：
```cpp
for (int *b = arr; b != e;++b)
    cout << *b << endl;
```

### 标准库函数begin和end
尽管能计算得到尾后指针，但这种做法极易出错。为了让指针的使用更简单、更安全，C++ 11新标准引入了两个名为`begin`和`end`的函数。这两个函数与容器中的两个同名成员功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用方法是将数组作为它们的参数：
```cpp
int ia[] = {0,1,2,3,4,5,6,7,8,9};
int *beg = begin(ia);
int *last = end(ia);
```

这两个函数定义在`iterator`头文件中

### 指针运算
指向数组元素的指针可以执行所有迭代器运算。这些运算，包括解引用、递增、比较、与整数相加、两个指针相减等，用在指针和用在迭代器上的意义完全一致。

### 下标和指针
在很多情况下使用数组名字其实使用的时指向一个数组首元素的指针。一个典型的例子是当数组使用下标运算符时，编译器回自动执行上述转换操作。
```cpp
int ia[] = {0,2,4,6,8};
```

此时，`ia[0]`是一个使用了数组名字的表达式，对数组执行下标运算其实是对指向数组元素的指针执行下标运算：
```cpp
int i = ia[2];

int *p = ia;
i = *(p + 2);
```

只要指针指向的是数组中的元素（或数组中尾元素的下一个位置），都可以执行下标运算：
```cpp
int *p = &ia[2];
int j = p[1];         //p[1]等价于*(p + 1),就是ia[3]表示的那个元素
int k = p[-2];        //p[-2]是ia[0]表示的那个元素
```