[TOC]

# C3.3 标准库类型vector
标准库类型**vector**表示对象的集合其中所有对象的类型都相同。

集合中的每一个对象都有一个与之对应的索引，索引用于访问对象。因为`vector`“容纳着”其他对象，所以它也被称作**容器**。

要想使用`vector`，必须包含适当的头文件。在后续的例子中，都将假定做了如下`using`声明：
```cpp
#include <vector>
using std::vector;
```

C++ 语言既有**类模板（class template）**，也有函数模板，其中`vector`是一个类模板。

模板本身不是类或者函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为**实例化（instantiation）**，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

对于类模板来说，我们通过一些额外信息来制定模板到底实例化成什么样的类，需要提供哪些信息有模板决定。

提供信息的方式总是这样：**即在模板名字后面跟一对尖括号，在括号内放上信息**。
```cpp
vector<int> ivec;        //ivec保存int类型的对象
vector<string> svec;
vector<vector<string>> file;    //该向量元素是vector对象
```

`vector`能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不包含引用的`vector`。除此之外，其他大多数（非引用）内置类型和类类型都可以构成`vector`对象，甚至组成`vector`的元素也可以是`vector`。

## 定义和初始化vector对象
和任何类型一样，`vector`模板控制着定义和初始化向量的方法。

|表达式|说明|
|---|---|
|`vector<T> v1`|`v1`是一个空`vector`，它潜在的元素是`T`类型的，执行默认初始化|
|`vector<T> v2(v1)`|`v2`中包含有`v1`所有元素的副本|
|`vector<T> v2 = v1`|等价于`v2(v1)`,`v2`中包含了`v1`所有元素的副本|
|`vector<T> v3(n,val)`|`v3`包含了`n`个重复元素，每个元素的值都是`val`|
|`vector<T> v4(n)`|`v4`包含了`n`个重复地执行了初始化的对象|
|`vector<T> v5{a,b,c...}`|`v5`包含了初始值个数的元素，每个元素被赋予了相应的初始值|
|`vector<T> v5={a,b,c...}`|等价于`v5{a,b,c...}`|

### 默认初始化vector对象
可以默认初始化`vector`对象，从而创建一个指定类型的空`vector`：
```cpp
vector<string> svec;    //默认初始化，svec中不含任何元素
```

当然也可以在定义`vector`对象时指定元素的初始值。例如把一个`vector`对象的元素拷贝给另一个`vector`对象，此时，新`vector`对象的元素就是原`vector`对象对应元素的副本。注意，两个`vector`对象的类型必须相同。
```cpp
vector<int> ivec;
vector<int> ivec2(ivec);
vector<int> ivec3 = ivec;
vector<string svec(ivec2);        //错误：svec的元素类型和ivec不同
```

### 列表初始化vector对象
C++ 11新标准还提供了另外一种为`vector`对象的元素赋初值的方法，即列表初始化。
```cpp
vector<string> articles = {"this","is","an","article"};
```

### 创建执行数量的元素
还可以使用`vector`对象容纳的元素数量和所有元素的统一初始值来初始化`vector`对象：
```cpp
vector<int> ivec(10,-1);        //10个int类型的元素，每个都被初始化为-1
vector<string> svec(10,"hi!");  //10个string类型的元素，每个都被初始化为"hi!"
```

### 值初始化
通常情况下，可以提供`vector`对象容纳的元素数量而略去初始值。此时库会创建一个**值初始化的（value-initialized）**元素初值，并把它赋给容器中的所有元素。这个初值由`vector`对象中元素的类型决定。

如果`vector`对象的元素是内置类型，比如`int`，则元素初始值自动设为`0`。如果元素是某种类类型，比如`string`，则元素由类默认初始化。
```cpp
vector<int> ivec(10);        //10个元素，每个都初始化为0
vector<string> svec(10);     //10个元素，每个都是空string对象
```

对这种初始化的方式有两个特殊限制：
> - 有些类要求必须明确地提供初始值，如果`vector`对象中的元素类型不支持默认初始化，我们就必须提供初始值的元素值。
> - 如果只提供了元素数量而没有设定初始值，只能使用直接初始化

### 列表初始值还是元素数量？
在某些情况下，初始化的真实含义依赖于传递初始值时使用的是花括号还是圆括号。
```cpp
vector<int> v1(10);    //v1有10个元素，每个的值都是0
vector<int> v2{10};    //v2有1个元素，该元素的值是10

vector<int> v3(10,1);  //v3有10个元素，每个元素的值是1
vector<int> v4{10,1};  //v4有2个元素，值分别是10和1
```

如果用的是圆括号，可以说提供的值是用来构造（construct）`vector`对象的。

如果使用的是花括号，可以表述成我们想列表初始化（list initialize）该`vector`对象。

另一方面，如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造`vector`对象了。
```cpp
vector<string> v7{10};      //v7有10个默认初始化的元素
vector<string> v8{10,"hi"}; //v8有10个值为"hi"de 元素
```

## 向vector对象中添加元素
对`vector`对象来说，直接初始化的方式适用于3种情况：
> - 初始值已知且数量较少
> - 初始值是另一个`vector`对象的副本
> - 所有元素的初始值都一样。

但更常见的情况是：创建一个`vector`对象时并不清楚实际所需的元素的个数，元素的值也经常无法确定。还有些时候即使元素的初始值已知，但如果这些值总量较大而各不相同，那么在创建`vector`对象的时候执行初始化操作也会显得过于繁琐。

我们可以先创建一个空`vector`，然后在运行时再利用`vector`的成员函数**push_back**向其中添加元素。`push_back`负责把一个值当成`vector`对象的尾元素“压入（push）”`vector`对象的“尾端（back）”。
```cpp
vector<int> v1;
for (int i = 0;i < 100;++i)
    v1.pus_back(i + 1);
```

### 向vector对象添加元素蕴含的编程假定
由于能高效便捷地向`vector`对象中添加元素，很多编程工作被极大简化了。然而，这种简便性也伴随着一些对编写程序更高的要求：其中一条就是必须确保所写的循环正确无误，特别是在循环中有可能改变`vector`对象容量的时候。

## 其他vector操作
除了`push_back`外，`vector`还提供了几种其他操作，大多数都和`string`的相关操作类似。

|表达式|描述|
|---|---|
|`v.empty()`|如果`v`不含有任何元素，返回真；否则返回假|
|`v.size()`|返回`v`中元素的个数|
|`v.push_back()`|向`v`的尾端添加一个值为`t`的元素|
|`v[n]`|返回`v`中第`n`个位置上的元素的引用|
|`v1 = v2`|用`v2`中的元素拷贝替换`v1`中的元素|
|`v1 = {a,b,c...}`|用列表中元素的拷贝替换`v1`中的元素|
|`v1 == v2`，`v1 != v2`|`v1`和`v2`相等当且仅当它们的元素数量相同且对应位置的元素值都相同|
|`<`,`<=`,`>`,`>=`|顾名思义，用字典序进行比较|

### 计算vector内对象的索引
使用下标运算符能获取到指定的元素。和`string`一样，`vector`对象的下标也是从`0`开始计起，下标的类型是相应的`size_type`类型。只要`vector`对象不是常量，就能向下标运算符返回的元素赋值。也能通过计算得到`vector`内对象的索引，然后直接获取索引位置上的元素。

### 不能用下标形式添加元素
不能使用`vector`对象的下标形式添加元素。
```cpp
vector<int> ivec;        //空vector对象
for (decltype(ivec.size()) ix = 0;ix != 10;++ix)
    ivec[ix] = ix;       //严重错误：ivec不包含任何元素
```

这段代码是错误的，`ivec`是一个空`vector`，根本不包含任何元素，当然也就不能通过下标去访问任何元素！正确的方法是使用`push_back`
```cpp
for (decltype(ivec.size()) ix = 0;ix != 10;++ix)
    ivec.push_back(ix);
```