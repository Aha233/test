[TOC]

# 基本内置类型
**数据类型是程序的基础：它告诉我们数据的意义以及我们能够在数据上执行的操作**

## 算术类型（arithmetic type）
算术类型可分为两类：**整型** 和 **浮点型**

### 整型
|类型|含义|最小尺寸（该类型数据所占的比特数）|
|---|---|---|
|`bool`|布尔类型|未定义|
|`char`|字符|8位|
|`short`|短整型|16位|
|`int`|整型|16位|
|`long`|长整形|32位|
|`long long`|长整形|64位|

### 浮点型

|类型|含义|最小尺寸（该类型数据所占的比特数）|  
|---|---|---|
|`float`|单精度浮点数|6位有效数字|  
|`double`|双精度浮点数|10位有效数字|

### 带符号类型和无符号类型
整型可以划分为**带符号的（singed）** 和 **无符号的（unsigned）** 两种。  
带符号类型可以表示正数、负数或0，无符号类型则仅能表示大于0的值。

类型`int`，`short`，`long` 和`long long`都是带符号的，通过在这些类型名前添加`unsigned`就可以得到无符号类型。  
与其他类型不同，字符型被分为了三种：`char`，`signed char` 和 `unsigned char`。  [为什么？](/home/fan/vnote_notebooks/study/C++%20Primer%205th/补充内容/为什么char有三种类型.md)  

[建议：如何选择类型](/home/fan/vnote_notebooks/study/C++%20Primer%205th/建议/如何选择类型.md)

## 空类型（void）
空类型不对应具体的值，仅用于一些特殊的场合，最常见的就是作为函数的返回类型。

## 类型转换
对象类型定义了对象能够包含的数据和能参与的运算，其中一种运算被大多数类型支持，就是将对象从一种给定的类型**转换(convert)** 为另一种类型。

类型转换有两种形式：手动和自动。

我们在[这里 - 未完成]()对手动类型转换做详细的介绍。  

自动类型转换会在类型与赋值类型不匹配时发生，此处，我们来详细说明。

例如：
```cpp
bool b = 42;             //b为真
int i = b;               //i的值为1
i = 3.14;                //i的值为3
double pi = i;           //pi的值为3.0
unsigned char c = -1;    //假设char占8比特，c的值为255
signed char c2 = 256;    //假设char占8比特，c2的值是未定义的
```

类型所能表示的值的范围决定了转换的过程：
> - 当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为`0`则结果为`false`，否则为`true`。
> - 当我们把一个布尔值赋给整数类型时，初始值为`false`则结果为`0`，初始值为`true`则结果为`1`。
> - 当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。
> - 当我们把一个整数值赋给浮点类型时，小数部分记为`0`。如果给整数所占的空间超过了浮点类型的容量，精度可能有损失。
> - 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。
> - 当我们赋给带符号类型一个超出它表示范围的值时，结果是**未定义的(undefined)**。此时，程序可能继续工作，可能崩溃，也可能生成垃圾数据。

### 含有无符号类型的表达式
尽管我们不会故意给无符号类型对象赋一个负值，却可能（特别容易）写出这么做的代码。  
```cpp
unsigned u = 10;
int i = -42;
std::cout << i + i << std::endl;    //输出-48
std::cout << u + i << std::endl;    //如果int占32位，输出4294967264
```

当一个算数表达式中既有无符号数又有`int`值时，那个`int`值就会转换为无符号数。  

把负数转换为无符号数类似于直接给无符号数赋一个负值，结果等于这个负数加上无符号数的模。

当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不可能是一个负数。  

无符号数不小于`0`这一事实同样关系到循环的写法。例如我们打算输出`10`到`0`的递减序列。
```cpp
for (int i = 10;i >= 0;--i)
    std::cout << i << std::endl;
```
注意，使用无符号数重写这个循环就会发生错误。
```cpp
//错误：变量u永远也不会小于0，循环条件一直成立
for (unsigned u = 10;u >= 0;--u)
    std::cout << u << std::endl;
```
当`u` 等于`-1`时会被转换成一个合理的无符号数。  
我们可以使用`while`语句代替`for`语句，因为前者能够让我们在输出变量之前（而非之后）先减去`1`：
```cpp
unsigned u = 11;
while (u > 0){
    --u;
    std::cout << u << std::endl;
}
```

## 字面值常量
一个形如`56`的值被称作**字面值常量(literal)**，这样的值一望而知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

### 整型和浮点型字面值
我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式。  以`0`开头的整数代表八进制，以`0x`或`0X`开头的代表十六进制数。  
例如，我们可以用下面任意一种形式来表示数值`20`：  
> - 20        // 十进制
> - 024      //八进制
> - 0x14    //十六进制

整型字面值具体的数据类型由它的值和符号决定。  
默认情况下，十进制字面值是带符号数，八进制和十六进制字面值即可能是带符号的也可能是无符号的。  
十进制字面值的类型是`int`，`long` 和 `long long`中尺寸最小的那个，前提是这种类型可能容纳下当前的值。  
八进制和十六进制的字面值类型是能容纳其数值的`int`，`unsigned int`，`long`，`unsigned long`，`long long`和`unsigned long long`中尺寸最小者。  
`short`没有对应的字面值。  
我们亦可以在字面值加后缀代表字面值类型。

尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进制字面值不会是负数。如果我们使用了一个形如`-42`的负十进制字面值，那个负号并不在字面值内，它的作用仅仅是对字面值取负值而已。

浮点型字面值表现为一个小数或者以科学计数法表示的指数，其中指数部分用`E`或`e`标识。  
`3.14    1,34E0    0.    0e0    .001`

默认的，浮点类型字面值是一个`double`，我们同样可以使用后缀来表示其他浮点型。

### 字符和字符串字面值
由单引号括起来的字符称为`char`型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。  
```cpp
'a'    //字符字面值
"Hello World!"    //字符串字面值
```
字符串字面值的类型实际上是由字符串常量构成的数组（array），该类型在[这儿 - 未完成]()介绍。编译器会在每个字符串的结尾处添加一个空字符（`'\0'`），因此，字符串字面值的实际长度要比它的内容多`1`。

如果两个字符串字面值紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。
```cpp
// 分多行写的字符串字面值
std::cout << "a really, really long string literal "
             "that spans two lines " << std::endl;
```

### 转义序列
有两类字符我们不能直接使用：
> - 不可打印的字符：如退格或其他控制字符，因为它们没有可视的图符。
> - 在C++中有特殊含义的字符（单引号、双引号、问号、反斜线）

如果要使用在C++这些字符，我们需要用到**转义序列(escape sequence)**，转义序列均以反斜线作为开始，C++语言规定的转义序列包括：  
> - `\n` 换行符
> - `\t` 横向制表符
> - `\a` 报警符
> - `\v` 纵向制表符
> - `\b` 退格符
> - `\"` 双引号
> - `\\` 反斜线
> - `\?` 问号
> - `\'` 单引号
> - `\r` 回车符
> - `\f` 进纸符

### 指定字面值的类型
前面谈到，我们可以添加后缀来指定整型、浮点型和字符型的字面值的默认类型。

`42ULL` 无符号整型字面值，类型是`unsigned long long`

### 布尔字面值和指针字面值
`true`和`false`是布尔类型的字面值