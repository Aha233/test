[TOC]

# C2.3 复合类型
**复合类型（compound type）** 是指基于其他类型定义的类型。  
C++ 语言有几种复合类型，本章将介绍其中的两种：**引用** 和 **指针**.

关于更声明语句更通用的描述是：  
> 一条声明语句由**基本数据类型（base type）** 和紧随其后的一个**声明符（declarator）** 列表组成。  
每个声明符命令了一个变量并指定该变量为基本数据类型有关的某种类型。

## 引用
**引用（reference）** 为对象起了另一个名字，引用类型引用（refer to）另外一种类型。  
通过将声明符写成`&d`形式来定义引用类型，其中`d`是声明的变量名。

```cpp
int ival = 2048;
int &refVal = ival;    //refVal指向ival（是ival的另一个名字）
int &refVal2；         //报错：引用必须被初始化
```

一般初始化变量时，初始值会被拷贝到新建的对象中。  
然而定义引用时，程序把引用和它的初始值**绑定（bind）**在一起，而不是将初始值拷贝给引用。  
一旦引用完成，引用将和它的初始值对象一直绑定在一起。  
因为无法另引用重新绑定到另一个对象，因此引用必须初始化。

### 引用即别名
> 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。

定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的：  
```cpp
refVal = 2;        //把2赋给refVal指向的对象，此处即是赋给了ival
int li = refVal    //与li = ival 执行结果一样
```

为引用赋值，实际上是把值赋给了与引用绑定的对象。  
获取引用的值，实际上是获取了与引用绑定的对象的值。  
以引用作为初始值，实际上是以与引用绑定的对象作为初始值  

```cpp
//正确:refVal3绑定到了那个与refVal绑定的对象上
int &refVal3 = refVal;
//利用与refVal绑定的对象的值初始化变量i
int i = refVal;
```

因为引用本身不是一个对象，所以不能定义引用的引用。
### 引用的定义
允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号`&`开头。  
```cpp
int i = 2048,i2 = 4096;
int &r = i,r2 = i2;        //r是一个引用，与i绑定在一起，r2是int
int i3 = 1024, &ri = i3;   //i3是int,ri是一个引用，与i3绑定在一起
int &r3 = i3, &r4 = i2;    //r3 和 r4都是引用
```

除去[2.4.1]() 和[15.2.3]() 的两种列外情况，其他所有引用的类型都要和与之绑定的对象严格匹配。  
引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起  
```cpp
int &refVal4 = 10;        //错误：引用类型的初始值必须是一个对象
double dval = 3.14;
int &refVal5 = dval;      //错误：此处引用类型的初始值必须是int类型对象
```

## 指针
**指针（pointer）** 是“指向（point to）”另外一种类型的复合类型。  
与引用类似，指针也实现了对其他对象的间接访问。  
指针与引用有一些不同点：  
> - 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
> - 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

定义指针类型的方法是将声明符写成`*d`的形式，其中`d`是变量名。  
如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号`*`：  
```cpp
int *ip1,*ip2;        //ip1和ip2都是指向int型对象的指针
double dp,*dp2;       //pd2是指向double型对象的指针，dp是double型对象
```

### 获取对象的地址
指针存放某个对象的地址，要想获取该地址，需要使用**取地址符（&）**。  
```cpp
int ival = 42;
int *p = &ival;    //p存放变量ival的地址，或者说p是指向变量ival的指针
```

因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。

除了[]() 和 []() 将要介绍的两种例外情况，其他所有指针类型都要和它所指向的对象严格匹配：  
```cpp
double dval;
double *pd = &dval;    //正确：初始值是double型对象的地址
double *pd2 = pd;      //正确：初始值是指向double对象的指针

int *pi = pd;          //错误：指针pi的类型和pd的类型不匹配
pi = &dval;            //错误：试图把double型对象的地址赋给int指针
```

### 指针值
指针的值（即地址）应属下列4种状态之一：  
> - 指向一个对象
> - 指向紧邻对象所占空间的下一个位置
> - 空指针，意味着指针没有指向任何对象
> - 无效指针，也就是上述情况之外的其他值

试图拷贝或以其它方式访问无效指针的值都将引发错误。  
尽管第2种和第3种形式的指针都是有效的，但其使用同样都到限制。显然这些指针没有指向任何具体对象，所以试图访问此类指针（假定的）对象的行为不被允许。

### 利用指针访问对象
如果指针指向了一个对象，则允许使用**解引用符（\*)**来访问该对象：  
```cpp
int ival = 42;
int *p = &ival;        //p存放着ival的地址，或者说p是指向变量ival的指针
cout << *p;            //由符号*得到指针p所指向的对象，输出42
```

对指针解引用会得出所指向的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值：
```cpp
*p = 0;
cout << *p;        //输出0
```

### 空指针
**空指针（null pointer）**不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。  
以下是几种生成空指针的方法：
```cpp
int *p1 = nullptr;          //等价于int *p1 = 0;
int *p2 = 0;                //直接将p2初始化为字面常量0
//需要先#include <cstdlib>
int *p3 = NULL;             //等价于int *p3 = 0;
```

`nullptr`是C++ 引进的一个新的字面值（0）。它可以被转化成任意其他的指针类型

把`int`变量直接赋值给指针是错误的操作，即使`int`变量的值恰好等于`0`也不行。
```cpp
int zero = 0;
p = zero;        //错误：不能把int变量直接赋值给指针
```

### 赋值和指针
指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上二者有很大不同，其中最重要的一点就是引用本身并非一个对象。一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。

指针和它存放的地址之间就没有这种限制了。 和其他任何变量（只要不是引用）一样，给指针赋值就是令它存放一个新的地址，从而指向一个新的对象：
```cpp
int i = 42;
int *pi = 0;        //pi被初始化，但没有指向任何对象
int *pi2 = &i;      //pi2被初始化，存有i的地址
int *pi3;           //如果pi3定义与块内，则pi3的值是无法确定的

pi3 = pi2;          //pi3 和 pi2指向同一对象i
pi2 = 0;            //pi2不指向任何对象了
```

### void* 指针
**void\***是一种特殊的指针类型，可用于存放任意对象的地址。  
一个`void *`指针存放着一个地址，这一点和其他指针类似，不过，我们对改地址中到底是个什么类型的对象并不了解：  
```cpp
double obj = 3.14, *pd = &odbj;    //正确：void*能存放任意类型的地址
void *pv = &obj;                   //obj可以是任意类型的对象
pv = pd;                           //pv可以存放任意类型的指针
```

## 理解复合类型的声明
变量的定义包含一个基本数据类型（base type）和一组声明符。  
在同一条语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。  
```cpp
//i是一个int型数据，p是一个int型指针，r是一个int型引用
int i = 2048, *p = &i,&r = i;
```

### 指向指针的指针
一般来说，声明符中修饰符的个数没有限制。  
当多个修饰符连写在一起时，按照其逻辑关系详加解释即可。  

通过`*`的个数可以区分指针的级别。  
也就是说，`**`表示指向指针的指针，`***`表示指向指针的指针的指针
```cpp
int ival = 1024;
int *pi = &ival;
int **ppi = &pi;
```

### 指向指针的引用
引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：  
```cpp
int i = 42;
int *p;                //p是一个指向int型的指针
int *&r = p;           //r是一个对指针p的引用

r = &i;                //r引用了一个指针，因此给r赋值&i就是令p指向i
*r = 0;                //解引用r得到i，也就是p指向的对象，将i的值改为0
```

要理解`r`的类型究竟是什么，最简单的办法就是从右往左阅读`r`的定义。离变量名最近的符号对变量的类型有最直接的影响，因此`r`是一个引用。声明符的其余部分用以确定`r`引用的类型是什么，此例中的符号`*`说明`r`的引用是一个指针。最后，声明的基本数据类型部分指出`r`引用的是一个`int`指针。

