[TOC]

# C2.2 变量
变量提供一个具名的、可供程序操作的存储空间。  
C++ 中每个变量都有其数据类型，数据类型决定着变量所占用内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能够参与的运算。  
对C++ 程序员来说，”变量（variable）“ 和 ”对象（object）”一般可以相互使用。

## 变量定义
变量定义的基本形式是：  
首先是**类型说明符（type specifier）**，随后紧跟由一个或多个变量名组成的列表，其中变量名一逗号分隔，最后以分号结束。  
列表中的每个变量名的类型由类型说明符指定，定义时还可以为一个或多个变量赋初值：  
```cpp
int sum = 0,value,
    units_sold = 0;    //sum,value和units_sold都是int
std::string str;            //str的类型是string
std::string book("1984");   //book 通过一个string字面值初始化
```

[术语 - 何为对象？]()

### 初始值
当对象在创建时获得了一个特定的值，我们说这个对象被**初始化（initialized）**了。

用于初始化变量的值可以是任意复杂的表达式。

当一次定义了两个或多个变量时，对象的名字随着定义也就马上可以使用了，因此在同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量。
```cpp
double price = 109.99,discount = price * 0.16;
double salePrice = applyDiscount(price,discount);
```

在C++ 语言中，初始化和赋值是两个完全不同的操作，但它们的区别非常小，我们特别容易将二者混为一谈。  
> 记住：初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

### 列表初始化
C++ 语言提供了定义初始化的好几种不同形式，这也是初始化问题复杂性的一个体现。  
```cpp
int num = 0;
int num = {0};
int num(0);
int num{0};
```

在C++ 11中，用花括号来初始化变量得到了全面应用。这种初始化的形式被称为**列表初始化（list initialization）**。

### 默认初始化
如果定义变量时没有指定初值，则变量被**默认初始化（default initialization）**，此时变量被赋予了“默认值”。   
默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。

如果是内置类型的变量未被初始化，它的值有定义的位置决定。  
定义于任何函数体之外的变量被初始化为`0`。  
定义在函数体内部的内置变量将**不被初始化（uninitialized）**。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。

每个类各自决定其初始化对象的方式。而且，是否允许不经过初始化就定义对象也由类自己决定。

绝大多数类都支持无需显式初始化而定义对象，这样的类提供了一个合适的默认值。

一些类要求每个对象都显式初始化，此时如果创建了一个该类的对象而未对其做明确的初始化操作，将引发错误。

## 变量声明与定义的关系
为了允许把程序拆分成多个逻辑部分来编写，C++ 语言支持**分离式编译（separate compilation）**机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。

如果程序被分为多个文件，则需要有在文件间共享代码的方法。一个实际例子是`std::cout`和`std::cin`，它们定义于标准库，却能被我们写的程序使用。

为了支持分离式编译，C++ 语言将声明和定义区分开来。  
**声明（declaration）**使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。  
**定义（definition）**负责创建与名字关联的实体。

变量声明规定了变量的类型和名字，在这一点上与定义相同。  
定义既声明了变量的类型和名字，又为变量申请了存储空间，也有可能为变量赋一个初始值。

如果想声明一个变量而非定义它，就在变量名前添加关键字`extern`，而且不要显式地初始化变量。
```cpp
extern int i;    //声明i而非定义i
int j;           //声明并定义j
```

任何包含了显式初始化的声明即成为定义。

在函数体内部，如果试图初始化一个由`extern`关键字标记的变量将会引发错误。

> 变量只能被定义一次，但是可以被多次声明。

## 标识符
C++ 标识符（identifier）由字母、数字和下划线组成，其中必须以字母或下划线开头。  
标识符的长度没有限制，但对大小写敏感：
```cpp
//几种不同的int变量
int somename,someName,SomeName,SOMENAME
```

C++ 语言保留了一些名字供语言本身使用，这些名字不能被用作标识符。  

|1|2|3|4|5|
|---|---|---|---|---|
|`alignas`|`continue`|`friend`|`register`|`true`|
|`alignof`|`decltype`|`goto`|`reinterpret_case`|`try`|
|`asm`|`default`|`if`|`return`|`typedef`|
|`auto`|`delete`|`inline`|`short`|`typeid`|
|`bool`|`do`|`int`|`signed`|`typename`|
|`break`|`double`|`long`|`sizeof`|`union`|
|`case`|`dynamic_case`|`mutable`|`static`|`unsigned`|
|`catch`|`else`|`namespace`|`static_assert`|`using`|
|`char`|`enum`|`new`|`static_case`|`virtual`|
|`char16_t`|`explicit`|`noexcept`|`struct`|`void`|
|`char32_t`|`export`|`nullptr`|`switch`|`volatile`|
|`class`|`extern`|`operator`|`template`|`wchar_t`|
|`const`|`false`|`private`|`this`|`while`|
|`constexpr`|`float`|`protected`|`thread_local`|`const_cast`|
|`for`|`public`|`throw`|

## 名字的作用域
无论是在程序的什么位置，使用到的每一个名字都会指向一个特定的实体：变量、函数、类型等。  
然而，同一个名字如果出现在程序的不同位置，也可能指向的是不同的实体。

**作用域（scope）**是程序的一部分，在其中名字有其特定的含义。  
C++ 语言中大多数作用域都以花括号分隔。

同一名字在不同的作用域中可能指向不同的实体。  
名字的有效区间始于名字的声明语句，以声明语句所在的作用域末端为结束。

### 嵌套的作用域
作用域能彼此包含，被包含（或者说被嵌套）的作用域称为**内层作用域（inner scope）**，包含着别的作用域的作用域被称为**外层作用域（outer scope）**

作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。  
同时，允许在内存作用域中重新定义外层作用域已有的名字。

> 如果函数有可能使用到某全局变量，则不宜再定义一个同名的局部变量。