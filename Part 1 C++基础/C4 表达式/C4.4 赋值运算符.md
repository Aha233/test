# C4.4 赋值运算符
赋值运算符的左侧运算对象必须是一个可修改的左值。

如果给定
```cpp
int i = 0,j = 0,k = 0;       //初始化而非赋值
const int ci = i;            //初始化而非赋值
```

则下面的赋值语句都是非法的
```cpp
1024 = k;                    //错误：字面值是右值
i + j = k;                   //错误：算术表达式是右值
ci = k;                      //错误：ci是常量（不可修改的）左值
```

赋值运算的结果是它的左侧运算对象，并且是一个左值。相应地，结果的类型就是左侧运算对象的类型。如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型：
```cpp
k = 0;                       //结果：类型是int，值是0
k = 3.14;                    //结果：类型是int，值是3
```

## 赋值运算满足右结合律
赋值运算符满足右结合律，这一点与其他二元运算符不太一样：
```cpp
int ival,jval;
ival = jval = 0;             //正确：都被赋值为0
```

对于多重赋值语句中的每个对象，它的类型或者与右边对象的类型相同，或者可由右边对象的类型转换得到。
```cpp
int ival, *pval;
ival = pval = 0;             //错误：不能把指针的值赋给int
string s1,s2;
s1 = s2 = "OK";              //字符串字面值“OK”转换成string对象
```

## 赋值运算优先级比较
赋值语句经常出现在条件当中。因为赋值运算的优先级相对较低，所以通常需要给赋值部分加上括号使其符合我们的原意。
```cpp
int i;
while ((i = getValue()) != 42) {
    //do something
}
```

## 切勿混淆相等运算符和赋值运算符
C++ 言语允许用赋值运算作为条件，但是这一特性可能带来意想不到的后果：
```cpp
if (i = j)
```

此时，`if`语句的条件部分把`j`的值赋给`i`，然后检查赋值的结果是否为真。如果`j`不为`0`，条件将为真。然而程序员的初衷很可能是向判断`i`和`j`是否相等：
```cpp
if (i == j)
```

## 复合赋值运算符
我们经常需要对对象施以某种运算，然后把计算的结果在赋值给该对象。
```cpp
int sum = 0;
for (int val = 1;val <= 10;++val)
    sum += val;
```

这种复合操作不仅对加法来说很常见，而且也常常应用与其他运算符或者位运算符。每种运算符都有相应的复合赋值形式：
```cpp
+=     -=     *=    /=    %=    //算术运算符
<<=    >>=    &=    ^=    |=    //位运算符
```

任意一种复合运算符都完全等价于：
```cpp
a = a op b;
```

唯一的区别是左侧运算对象的求值次数：使用复合运算符只求值一次，使用普通的运算符则求值两次。这两次包括：一次作为右边子表达式的一部分求值，另一次是作为赋值运算的左侧运算对象求值。

