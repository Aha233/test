# C4.5 递增和递减运算符
递增运算符（`++`）和递减运算符（`--`）为对象的加`1`和减`1`操作提供了一种简洁的书写形式。这两个运算符还可以应用于迭代器，因为许多迭代器本身不支持算术运算，所以此时递增和递减运算符除了书写简洁之外还是必须的。

递增和递减运算符有两个版本：
- 前置版本：首先将运算对象加`1`（或减`1`），然后将改变后的对象作为求值结果。
- 后置版本：先将对象作为求值结果，然后将对象加`1`（或减`1`）

建议：[除非必须，否则不用递增递减运算符的后置版本]()

## 在一条语句中混用解引用和递增运算符
如果我们想在一条复合表达式中既将变量加`1`或减`1`又能使用它原来的值，这时就可以使用递增和递减运算符的后置版本。

举个例子，可以使用后置的递增运算符来控制循环输出一个`vector`对象内容直到遇见（但不包括）第一个负值为止：
```cpp
auto pbeg = v.begin();

while (pbeg != v.end() && *pbeg >= 0)
    cout << *pbeg++ << endl;
```

`*pbeg++`可能不太容易理解。其实这种写法非常普遍，所以一定要理解其含义。

后置递增运算符的优先级高于解引用运算符，因此`*pbeg++`等价于`*(pbeg++)`。  
`pbeg++`把`pbeg`的值加`1`，然后返回`pbeg`的初始值的副本作为其求值结果，此时解引用运算符的运算对象是`pbeg`未增加之前的值。最终，这条语句输出`pbeg`开始指向的那个元素，并将指针向前移动一个位置。

## 运算对象可按任意顺序求值
大多数运算符都没有规定运算对象的求值顺序，这在一般情况下不会有什么影响。然而，如果一条子表达式改变了某个运算对象的值，另一条子表达式又要使用该值的话，运算对象的求值顺序就很关键了。因为递增运算对象和递减运算对象回改变运算对象的值，所以要提防在复合表达式中错用这两个运算符。

```cpp
for (auto it = s.begin(); it != s.end() && !isspace(*it); ++it)
    *it = toupper(*it);        //正确
```

```cpp
while (beg != s.end() && !isspace(*beg))
    *beg = toupper(*beg++);    //错误：该赋值语句未定义
```

问题在于：赋值运算符左右两端的运算对象都用到了`beg`，并且右侧的运算对象还改变了`beg`的值，所以该赋值语句是未定义的。编译器可能按照下面的任意一种思路处理该表达式：
```cpp
*beg = toupper(*beg);              //如果先求左侧的值
*(beg + 1) = toupper(*beg);        //如果先求右侧的值
```

也可能采取别的什么方式处理它